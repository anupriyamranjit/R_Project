sum(data_original$isFlaggedFraud)
# Setup
knitr::opts_chunk$set(echo = TRUE)
# Import Data
data1 <- read.csv('./Fraud.csv')
# Copy Data
data_original <- data1
# See Structure of Data and Summary for any issues
str(data_original)
summary(data_original)
# Check Number of NA values in data
sum(is.na(data_original))
sum(data_original$isFlaggedFraud)
# Does the data make sense
sum(data_original$oldbalanceOrg - data_original$newbalanceOrig)
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig)
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig))
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig))
sum(amount)
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig))
sum(data_original$amount)
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig))
sum(data_original$amount)
# Does the data make sense
sum(abs(data_original$oldbalanceOrg - data_original$newbalanceOrig))
# Does the data make sense
old = sum(abs(data_original$oldbalanceOrg))
new = sum(abs(data_original$newbalanceOrig))
abs(old - new) == sum(data_original$amount)
# Does the data make sense
old = sum(abs(data_original$oldbalanceOrg))
new = sum(abs(data_original$newbalanceOrig))
abs(old - new)
== sum(data_original$amount)
# Does the data make sense
old = sum(abs(data_original$oldbalanceOrg))
new = sum(abs(data_original$newbalanceOrig))
abs(old - new)
sum(data_original$amount)
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
old <- sum(abs(data_original$newbalanceOrg[data_original$type == "CASH-IN"]))
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
new <- sum(abs(data_original$newbalanceOrg[data_original$type == "CASH-IN"]))
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
new <- sum(abs(data_original$newbalanceOrig[data_original$type == "CASH-IN"]))
abs(old - new)
sum(data_original$amount)
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
new <- sum(abs(data_original$newbalanceOrig[data_original$type == "CASH-IN"]))
abs(old - new)
sum(data_original$amount)
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
print(old)
new <- sum(abs(data_original$newbalanceOrig[data_original$type == "CASH-IN"]))
print(new)
abs(old - new)
sum(data_original$amount)
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-IN"]))
print(old)
new <- sum(abs(data_original$newbalanceOrig[data_original$type == "CASH-IN"]))
print(new)
abs(old - new)
sum(data_original$amount[data_original$type == "CASH-IN"])
# Does the data make sense
old <- sum(abs(data_original$oldbalanceOrg[data_original$type == "CASH-OUT"]))
print(old)
new <- sum(abs(data_original$newbalanceOrig[data_original$type == "CASH-OUT"]))
print(new)
abs(old - new)
sum(data_original$amount[data_original$type == "CASH-OUT"])
data_original[duplicated(data_original)]
cash_out_rows <- data_original[data_original$type == "CASH_OUT", ]
cash_out_rows
data_original$merchant <- ifelse(substr(data_original$nameDest, 1, 1) == 'M', TRUE, FALSE)
View(data_original)
View(data_original)
data_original$merchant <- ifelse(substr(data_original$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_original$isFraud <- as.logical(data_original$isFraud)
View(data_original)
View(data_original)
# Preprocess Data
data_original$merchant <- ifelse(substr(data_original$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_original$isFraud <- as.logical(data_original$isFraud)
data_original$isFlaggedFraud <- NULL
View(data_original)
knitr::opts_chunk$set(echo = TRUE)
pgdata <- read.csv("pilgrim_bank_data.csv")
pgdata_original <- pgdata
str(pgdata)
pgdata$X9District <- as.factor(pgdata$X9District)
str(pgdata)
summary(pgdata)
hist(pgdata$X9Profit)
plot(density(pgdata$X9Profit))
plot(ecdf(pgdata$X9Profit))
pairs(~X9Age+X9Inc+X9Tenure+X9Profit,data=pgdata[sample(nrow(pgdata),100),],main="Plots")
# compact version
pgdata$IncMeaned <- pgdata$X9Inc
pgdata$IncMeaned[is.na(pgdata$IncMeaned)] <- mean(pgdata$X9Inc[!is.na(pgdata$X9Inc)])
# using more variables to make it more readable
ageMissing <- is.na(pgdata$X9Age)
meanAge <-mean(pgdata$X9Age[!ageMissing])
pgdata$AgeMeaned <- pgdata$X9Age
pgdata$AgeMeaned[ageMissing]<-meanAge
View(pgdata)
pgdata$AgeExists <- !is.na(pgdata$X9Age)
pgdata$IncExists <- !is.na(pgdata$X9Inc)
pgdata$X9District <- as.factor(pgdata$X9District)
pgdata$y <- !is.na(pgdata$X0Profit)
# Setup
knitr::opts_chunk$set(echo = TRUE)
# Import Data
data_original <- read.csv('./Fraud.csv')
# Copy Data
data_copy <- data_original
# See Structure of Data and Summary for any issues
str(data_copy)
summary(data_copy)
# Check Number of NA values in data
sum(is.na(data_copy))
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
as.factor?
q
?as.factor
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
data_copy$type <- as.factor(data_copy$type)
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
data_copy$type <- as.factor(data_copy$type)
data_copy
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
data_copy$type <- as.factor(data_copy$type)
data_copy
summary(data_copy)
knitr::opts_chunk$set(echo = TRUE)
# Setup
knitr::opts_chunk$set(echo = TRUE)
# Import Data
data_original <- read.csv('./Fraud.csv')
# Copy Data
data_copy <- data_original
# See Structure of Data and Summary for any issues
str(data_copy)
summary(data_copy)
# Check Number of NA values in data
sum(is.na(data_copy))
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
data_copy$nameOrig <- NULL
data_copy$nameDest <- NULL
data_copy$type <- as.factor(data_copy$type)
data_copy
summary(data_copy)
set.seed(10)
smp_size <- floor(0.75 * nrow(data_copy))
smp_size
set.seed(100)
train_ind <- sample(1:nrow(data_copy), size = smp_size)
train <- data_copy[train_ind, ]
test <- data_copy[-train_ind, ]
knitr::opts_chunk$set(echo = TRUE)
# lets define the response variable
y <- train$isFraud
# lets define a matrix of all features except for the columns related to the response variable
all_column_names <- colnames(train)
all_columns_noFraud <- all_column_names[all_column_names != "isFraud"]
x <- data.matrix(train[, all_columns_noFraud])
library(glmnet)
library(Matrix)
# perform k-fold cross-validation to find optimal lambda value (using the default k=10 folds)
# use alpha=1 as we want to fit the lasso regression model
cv_model <- cv.glmnet(x, y, alpha = 1)
# determine optimal lambda value that minimizes test mean squared error (MSE)
optimal_lambda <- cv_model$lambda.min
print("The Optimal Lambda is:")
optimal_lambda
# produce plot of test mean squared error (MSE) by lambda value
plot(cv_model)
# determine coefficient estimates for each variable of the regularized model
regularized_model <- glmnet(x, y, alpha = 1, lambda = optimal_lambda)
coef_matrix <- coef(regularized_model)
coef_matrix
# drop the Intercept column as it is not needed
row_index <- which(rownames(coef_matrix) == "(Intercept)")
coef_matrix_noIntercept <- coef_matrix[-row_index, , drop = FALSE]
# store only the feature names that don't have a coefficient of 0
ideal_features <- rownames(coef_matrix_noIntercept)[coef_matrix_noIntercept[, 1] != 0][]
ideal_features
# construct the formula as a string
formula_string <- paste("isFraud ~", paste(ideal_features, collapse = " + "))
formula_string
# convert the formula string to a formula object
formula_object <- as.formula(formula_string)
print("Final relation:")
print(formula_object)
# define and train each of the classifiers
library(rpart)
tree1 <- rpart(formula_object,method="class", data=train, cp=0.01)
tree2 <- rpart(formula_object,method="class", data=train, cp=0.001)
tree3 <- rpart(formula_object,method="class", data=train, cp=0.00001)
treeErr <- function(tree, dataset)
{
isFraud_hat = predict(tree,dataset,type="class")
tree.err = mean(dataset$isFraud != isFraud_hat)
return(tree.err)
}
print(paste("Test error for cp=0.01 is ",treeErr(tree1,test)))
print(paste("Train error for cp=0.01 is ",treeErr(tree1,train)))
print(paste("Test error for cp=0.001 is ",treeErr(tree2,test)))
print(paste("Train error for cp=0.001 is ",treeErr(tree2,train)))
print(paste("Test error for cp=0.000001 is ",treeErr(tree3,test)))
print(paste("Train error for cp=0.000001 is ",treeErr(tree3,train)))
results <- data.frame(Actual = test$isFraud, Predicted = idealFeatures)
results <- data.frame(Actual = test$isFraud, Predicted = ideal_features)
# save model
save(regularized_model, file="./reg_model.RData")
# save model
save(regularized_model, file="./reg_model.RData")
rm regularized_model
# save model
save(regularized_model, file="./reg_model.RData")
rm(regularized_model)
# load model
load("./reg_model.RData")
# save model
save(regularized_model, file="./reg_model.RData")
rm(regularized_model)
# load model
load("./reg_model.RData")
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(dataset$isFraud != isFraud_hat_test)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(dataset$isFraud != isFraud_hat_train)
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result <- list(
test_error = test_err,
train_error = train_err,
confusion_matrix = conf_matrix
)
return(result)
}
print(paste("Test error for cp=0.01 is ",treeErr(tree1,test)))
tree1Err <- treeErr(tree1, test, train)
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(test_dataset$isFraud != isFraud_hat_test)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(train_dataset$isFraud != isFraud_hat_train)
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result <- list(
test_error = test_err,
train_error = train_err,
confusion_matrix = conf_matrix
)
return(result)
}
tree1Err <- treeErr(tree1, test, train)
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(test_dataset$isFraud != test_pred)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(train_dataset$isFraud != train_pred)
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result <- list(
test_error = test_err,
train_error = train_err,
confusion_matrix = conf_matrix
)
return(result)
}
tree1Err <- treeErr(tree1, test, train)
print(tree1Err)
# print(paste("Test error for cp=0.01 is ",treeErr(tree1,test)))
# print(paste("Train error for cp=0.01 is ",treeErr(tree1,train)))
# print(paste("Test error for cp=0.001 is ",treeErr(tree2,test)))
# print(paste("Train error for cp=0.001 is ",treeErr(tree2,train)))
# print(paste("Test error for cp=0.000001 is ",treeErr(tree3,test)))
# print(paste("Train error for cp=0.000001 is ",treeErr(tree3,train)))
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(test_dataset$isFraud != test_pred)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(train_dataset$isFraud != train_pred)
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result_df <- data.frame(
Metric = c("Test Error", "Train Error"),
Value = c(test_err, train_err)
)
return(list(result_df, Confusion_Matrix = conf_matrix))
}
tree1Err <- treeErr(tree1, test, train)
print(tree1Err)
# print(paste("Test error for cp=0.01 is ",treeErr(tree1,test)))
# print(paste("Train error for cp=0.01 is ",treeErr(tree1,train)))
# print(paste("Test error for cp=0.001 is ",treeErr(tree2,test)))
# print(paste("Train error for cp=0.001 is ",treeErr(tree2,train)))
# print(paste("Test error for cp=0.000001 is ",treeErr(tree3,test)))
# print(paste("Train error for cp=0.000001 is ",treeErr(tree3,train)))
# tree1Err <- treeErr(tree1, test, train)
print(paste("Errors for tree1: ", treeErr(tree1, test, train)))
print(paste("Errors for tree2: ", treeErr(tree2, test, train)))
print(paste("Errors for tree3: ", treeErr(tree3, test, train)))
# print(paste("Test error for cp=0.01 is ",treeErr(tree1,test)))
# print(paste("Train error for cp=0.01 is ",treeErr(tree1,train)))
# print(paste("Test error for cp=0.001 is ",treeErr(tree2,test)))
# print(paste("Train error for cp=0.001 is ",treeErr(tree2,train)))
# print(paste("Test error for cp=0.000001 is ",treeErr(tree3,test)))
# print(paste("Train error for cp=0.000001 is ",treeErr(tree3,train)))
# Errors for tree2
tree2Err <- treeErr(tree2, test, train)
print(tree2Err)
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(test_dataset$isFraud != test_pred)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(train_dataset$isFraud != train_pred)
test_acc = 1 - test_err
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result_df <- data.frame(
Metric = c("Train Error", "Test Error", "Accuracy"),
Value = c(train_err, test_err, test_acc)
)
return(list(result_df, Confusion_Matrix = conf_matrix))
}
# Errors for tree2
tree2Err <- treeErr(tree2, test, train)
print(tree2Err)
save(cv_model, file="./reg_model.RData")
save(regularized_model, file="./regularized_model.RData")
save(tree1, file="./tree1.RData")
save(tree2, file="./tree2.RData")
save(tree3, file="./tree3.RData")
# Errors for tree1
tree1Err <- treeErr(tree1, test, train)
print(tree1Err)
# Errors for tree3
tree3Err <- treeErr(tree3, test, train)
print(tree3Err)
library(glmnet)
library(Matrix)
if (file.exists("./cv_model.RData")) {
# load cv_model
load("./cv_model.RData")
} else {
# create cv_model
# perform k-fold cross-validation to find optimal lambda value (using the default k=10 folds)
# use alpha=1 as we want to fit the lasso regression model
cv_model <- cv.glmnet(x, y, alpha = 1)
# save cv_model
save(cv_model, file="./reg_model.RData")
}
file.exists("./cv_model.RData")
save(cv_model, file="./cv_model.RData")
file.exists("./cv_model.RData")
file.exists("./regularized_model.RData")
file.exists("./tree1.RData")
file.exists("./tree2.RData")
file.exists("./tree3.RData")
# Create Training and Testing Sets
set.seed(10)
smp_size <- floor(0.75 * nrow(data_copy))
smp_size
set.seed(100)
train_ind <- sample(1:nrow(data_copy), size = smp_size)
train <- data_copy[train_ind, ]
test <- data_copy[-train_ind, ]
# define and train each of the classifiers
library(rpart)
if (file.exists("./tree1.RData")) {
# load tree1
load("./tree1.RData")
} else {
# create tree1
tree1 <- rpart(formula_object,method="class", data=train, cp=0.01)
# save tree1
save(tree1, file="./tree1.RData")
}
if (file.exists("./tree2.RData")) {
# load tree2
load("./tree2.RData")
} else {
# create tree2
tree2 <- rpart(formula_object,method="class", data=train, cp=0.001)
# save tree2
save(tree2, file="./tree2.RData")
}
if (file.exists("./tree3.RData")) {
# load tree3
load("./tree3.RData")
} else {
# create tree3
tree3 <- rpart(formula_object,method="class", data=train, cp=0.00001)
# save tree3
save(tree3, file="./tree3.RData")
}
treeErr <- function(tree, test_dataset, train_dataset)
{
test_pred = predict(tree,test_dataset,type="class")
test_err = mean(test_dataset$isFraud != test_pred)
train_pred = predict(tree,train_dataset,type="class")
train_err = mean(train_dataset$isFraud != train_pred)
test_acc = 1 - test_err
conf_matrix <- table(Actual = test_dataset$isFraud, Predicted = test_pred)
result_df <- data.frame(
Metric = c("Train Error", "Test Error", "Accuracy"),
Value = c(train_err, test_err, test_acc)
)
return(list(result_df, Confusion_Matrix = conf_matrix))
}
# Errors for tree1
tree1Err <- treeErr(tree1, test, train)
print(tree1Err)
setwd("/Users/neel/Documents/bu425/R_Project/Sales_Data")
# Setup
knitr::opts_chunk$set(echo = TRUE)
# Import Data
data_original <- read.csv('./Fraud.csv')
# Import Data
data_original <- read.csv('./Fraud.csv')
# Copy Data
data_copy <- data_original
# See Structure of Data and Summary for any issues
str(data_copy)
summary(data_copy)
# Check Number of NA values in data
sum(is.na(data_copy))
# Preprocess Data
data_copy$merchant <- ifelse(substr(data_copy$nameDest, 1, 1) == 'M', TRUE, FALSE)
data_copy$isFraud <- as.logical(data_copy$isFraud)
data_copy$isFlaggedFraud <- NULL
data_copy$nameOrig <- NULL
data_copy$nameDest <- NULL
data_copy$type <- as.integer(as.factor(data_copy$type))
summary(data_copy)
# Create Training and Testing Sets
set.seed(10)
smp_size <- floor(0.75 * nrow(data_copy))
smp_size
set.seed(100)
train_ind <- sample(1:nrow(data_copy), size = smp_size)
train <- data_copy[train_ind, ]
test <- data_copy[-train_ind, ]
# Create Training and Testing Sets
set.seed(10)
smp_size <- floor(0.75 * nrow(data_copy))
print(paste("Sample size: ", smp_size))
set.seed(100)
train_ind <- sample(1:nrow(data_copy), size = smp_size)
train <- data_copy[train_ind, ]
test <- data_copy[-train_ind, ]
# lets define the response variable
y <- train$isFraud
# lets define a matrix of all features except for the columns related to the response variable
all_column_names <- colnames(train)
all_columns_noFraud <- all_column_names[all_column_names != "isFraud"]
x <- data.matrix(train[, all_columns_noFraud])
library(glmnet)
library(Matrix)
if (file.exists("./cv_model.RData")) {
# load cv_model
load("./cv_model.RData")
} else {
# create cv_model
# perform k-fold cross-validation to find optimal lambda value (using the default k=10 folds)
# use alpha=1 as we want to fit the lasso regression model
cv_model <- cv.glmnet(x, y, alpha = 1, parallel = TRUE)
# save cv_model
save(cv_model, file="./cv_model.RData")
}
